import win32com.client
import zipfile
import os
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from pathlib import Path
import time
import shutil # <--- IMPORTANTE: AÃ±adido para una limpieza robusta

class ProcesadorReportesFraudeOutlook:
    def __init__(self):
        self.carpeta_historicos = "datos_historicos"
        self.carpeta_diarios = "datos_diarios"
        self.carpeta_temp = "temp"
        self.carpeta_graficas = "graficas_reportes"
        self.archivo_dashboard = "dashboard_fraudes.xlsx"
        
        # --- CAMBIO: Adaptado a tu carpeta real ---
        self.carpeta_outlook_objetivo = "monitor_diario"
        
        # Crear carpetas si no existen
        for carpeta in [self.carpeta_historicos, self.carpeta_diarios, 
                        self.carpeta_temp, self.carpeta_graficas]:
            Path(carpeta).mkdir(exist_ok=True)
        
        # Conectar a Outlook corporativo
        try:
            self.outlook = win32com.client.Dispatch("Outlook.Application")
            self.namespace = self.outlook.GetNamespace("MAPI")
            print("âœ… Conectado a Outlook corporativo")
        except Exception as e:
            print(f"âŒ Error al conectar con Outlook: {e}")
            raise
    
    def obtener_carpeta_personalizada(self):
        """Obtiene la carpeta personalizada desde Outlook"""
        try:
            inbox = self.namespace.GetDefaultFolder(6)  # 6 = Inbox
            carpeta_objetivo = inbox.Folders(self.carpeta_outlook_objetivo)
            print(f"âœ… Carpeta '{self.carpeta_outlook_objetivo}' encontrada")
            return carpeta_objetivo
        except Exception:
            print(f"âŒ Error: No se encontrÃ³ la carpeta '{self.carpeta_outlook_objetivo}' en tu Bandeja de Entrada.")
            # ... (cÃ³digo para listar carpetas)
            raise Exception(f"Carpeta '{self.carpeta_outlook_objetivo}' no encontrada")
    
    def procesar_correo_diario(self):
        """FunciÃ³n principal que ejecuta todo el flujo"""
        print(f"ğŸš€ Iniciando proceso diario - {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        datos_dia = self.extraer_excel_de_correo()
        
        if datos_dia is not None and not datos_dia.empty:
            print(f"ğŸ“Š Datos extraÃ­dos: {len(datos_dia)} registros")
            self.guardar_excel_diario(datos_dia)
            self.actualizar_dashboard_historico(datos_dia)
            graficas_generadas = self.generar_graficas_diarias(datos_dia)
            self.enviar_reporte_outlook(datos_dia, graficas_generadas)
            self.limpiar_archivos_temporales()
            print("âœ… Proceso completado exitosamente")
        else:
            print("âš ï¸ No se encontraron datos para procesar hoy")
    
    def extraer_excel_de_correo(self):
        """Extrae y combina todos los Excels del ZIP adjunto en correos de hoy."""
        try:
            carpeta_objetivo = self.obtener_carpeta_personalizada()
            hoy = datetime.now()
            fecha_filtro = hoy.strftime("%m/%d/%Y")
            print(f"ğŸ” Buscando correos del {fecha_filtro} en la carpeta '{self.carpeta_outlook_objetivo}'...")
            
            filtro = f"[ReceivedTime] >= '{fecha_filtro}'"
            messages = carpeta_objetivo.Items.Restrict(filtro)
            messages.Sort("[ReceivedTime]", True) # Ordenar por mÃ¡s reciente
            
            print(f"ğŸ“§ Encontrados {messages.Count} correos de hoy en '{self.carpeta_outlook_objetivo}'")
            
            for message in messages:
                if self.es_correo_reporte_fraude(message):
                    print(f"âœ… Correo de reporte encontrado: {message.Subject}")
                    for attachment in message.Attachments:
                        if attachment.FileName.lower().endswith('.zip'):
                            print(f"ğŸ“ Procesando ZIP: {attachment.FileName}")
                            zip_path = os.path.abspath(os.path.join(self.carpeta_temp, attachment.FileName))
                            attachment.SaveAsFile(zip_path)
                            datos = self.extraer_y_combinar_excels_de_zip(zip_path)
                            if datos is not None:
                                print("âœ… Todos los Excels del ZIP han sido extraÃ­dos y combinados.")
                                return datos
            
            print(f"âŒ No se encontrÃ³ un correo vÃ¡lido con reportes en la carpeta '{self.carpeta_outlook_objetivo}' para hoy.")
            return None
        except Exception as e:
            print(f"âŒ Error al procesar correo: {e}")
            return None
    
    def es_correo_reporte_fraude(self, message):
        """Determina si el correo contiene el reporte diario de fraudes"""
        try:
            remitente = ""
            if message.SenderEmailType == "EX":
                remitente = message.Sender.GetExchangeUser().PrimarySmtpAddress.lower()
            else:
                remitente = message.SenderEmailAddress.lower()

            asunto = str(message.Subject).lower()
            
            # --- CAMBIO: Criterios adaptados al correo real ---
            criterios_remitente = [
                "wilmer.valverde@scotiabank.com.pe"
            ]
            
            criterios_asunto = [
                "alertas por reporte", 
                "rep_8850" # Palabra clave del asunto
            ]
            
            remitente_valido = any(criterio in remitente for criterio in criterios_remitente)
            asunto_valido = any(criterio in asunto for criterio in criterios_asunto)
            tiene_adjuntos = message.Attachments.Count > 0
            
            if (remitente_valido and asunto_valido and tiene_adjuntos):
                print(f"ğŸ“‹ Candidato encontrado - Remitente: {remitente}, Asunto: {asunto}")
                return True
            return False
        except Exception as e:
            print(f"Error al evaluar correo: {e}")
            return False
    
    def extraer_y_combinar_excels_de_zip(self, zip_path):
        """
        MEJORADO: Extrae todos los archivos Excel de un ZIP y los combina en un Ãºnico DataFrame.
        """
        lista_dataframes = []
        try:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                archivos_excel = [f for f in zip_ref.namelist() if f.lower().endswith(('.xlsx', '.xls')) and not f.startswith('__MACOSX')]
                
                if not archivos_excel:
                    print("âŒ No se encontraron archivos Excel en el ZIP.")
                    return None
                
                print(f"ğŸ“Š Se encontraron {len(archivos_excel)} archivos Excel en el ZIP: {archivos_excel}")

                for archivo_excel in archivos_excel:
                    print(f"ğŸ”„ Procesando: {archivo_excel}")
                    zip_ref.extract(archivo_excel, self.carpeta_temp)
                    ruta_excel_extraido = os.path.join(self.carpeta_temp, archivo_excel)
                    
                    try:
                        df_temp = pd.read_excel(ruta_excel_extraido)
                        lista_dataframes.append(df_temp)
                        print(f"  - LeÃ­do exitosamente: {len(df_temp)} filas.")
                    except Exception as e:
                        print(f"  - âš ï¸ No se pudo leer el archivo {archivo_excel}. Error: {e}")
            
            if not lista_dataframes:
                print("âŒ No se pudo leer ningÃºn archivo Excel del ZIP.")
                return None

            # Combinar todos los DataFrames en uno solo
            datos_combinados = pd.concat(lista_dataframes, ignore_index=True)
            return datos_combinados
            
        except Exception as e:
            print(f"âŒ Error al extraer y combinar Excels del ZIP: {e}")
            return None
        finally:
            # Limpieza del ZIP temporal
            if os.path.exists(zip_path):
                os.remove(zip_path)

    # --- NINGÃšN CAMBIO NECESARIO EN LAS SIGUIENTES FUNCIONES ---
    # (guardar_excel_diario, actualizar_dashboard_historico, generar_graficas_diarias)
    # ... (Pega aquÃ­ tus funciones sin modificar) ...

    def limpiar_archivos_temporales(self):
        """MEJORADO: Limpia archivos y carpetas temporales de forma robusta."""
        print("ğŸ§¹ Limpiando archivos temporales...")
        try:
            if os.path.exists(self.carpeta_temp):
                shutil.rmtree(self.carpeta_temp) # Usa shutil para borrar la carpeta y todo su contenido
                print(f"ğŸ—‘ï¸ Carpeta temporal '{self.carpeta_temp}' eliminada.")
            
            os.makedirs(self.carpeta_temp, exist_ok=True) # La vuelve a crear vacÃ­a
        except Exception as e:
            print(f"âš ï¸ Error al limpiar archivos temporales: {e}")

    def enviar_reporte_outlook(self, datos, graficas):
        """EnvÃ­a reporte usando Outlook corporativo"""
        try:
            print("ğŸ“§ Preparando envÃ­o por Outlook corporativo...")
            mail = self.outlook.CreateItem(0)
            
            # --- CAMBIO: Puedes ajustar los destinatarios ---
            destinatarios = [
                "jose.cordova@scotiabank.com.pe" # Tu correo corporativo
            ]
            mail.To = "; ".join(destinatarios)
            
            fecha_reporte = datetime.now().strftime("%d/%m/%Y")
            # --- CAMBIO: Asunto y cuerpo ahora son dinÃ¡micos ---
            mail.Subject = f"[AUTOMATICO] Reporte Diario de Fraudes - {fecha_reporte} (Carpeta: {self.carpeta_outlook_objetivo})"
            
            mail.Body = f"""
REPORTE AUTOMATICO DE FRAUDES
Fuente: Carpeta Outlook '{self.carpeta_outlook_objetivo}'
Fecha: {fecha_reporte}
Hora de generaciÃ³n: {datetime.now().strftime("%H:%M:%S")}
{'-'*50}
ğŸ“Š RESUMEN EJECUTIVO
{'-'*50}
ğŸš¨ Total de transacciones analizadas: {len(datos)}
{'-'*50}
Este reporte ha sido generado automÃ¡ticamente.
            """
            
            for grafica in graficas:
                if os.path.exists(grafica):
                    mail.Attachments.Add(os.path.abspath(grafica))
                    print(f"ğŸ“ Adjuntado: {os.path.basename(grafica)}")
            
            fecha_hoy = datetime.now().strftime("%Y%m%d")
            excel_diario = os.path.join(self.carpeta_diarios, f"fraudes_{fecha_hoy}.xlsx")
            if os.path.exists(excel_diario):
                mail.Attachments.Add(os.path.abspath(excel_diario))
                print(f"ğŸ“ Adjuntado: fraudes_{fecha_hoy}.xlsx")
            
            mail.Importance = 2
            mail.Send()
            print(f"âœ… Reporte enviado exitosamente a: {', '.join(destinatarios)}")

        except Exception as e:
            print(f"âŒ Error al enviar correo: {e}")

# ... (El resto de tu script principal para llamar a la clase no necesita cambios)

--------------------------------------------------------------------
====================================================================
import win32com.client
import zipfile
import os
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from pathlib import Path
import time

class ProcesadorReportesFraudeOutlook:
    def __init__(self):
        self.carpeta_historicos = "datos_historicos"
        self.carpeta_diarios = "datos_diarios"
        self.carpeta_temp = "temp"
        self.carpeta_graficas = "graficas_reportes"
        self.archivo_dashboard = "dashboard_fraudes.xlsx"
        
        # NUEVA: Nombre de la carpeta personalizada en Outlook
        self.carpeta_outlook_objetivo = "prueba trx"  # Con espacio como aparece en tu Outlook
        
        # Crear carpetas si no existen
        for carpeta in [self.carpeta_historicos, self.carpeta_diarios, 
                       self.carpeta_temp, self.carpeta_graficas]:
            Path(carpeta).mkdir(exist_ok=True)
        
        # Conectar a Outlook corporativo
        try:
            self.outlook = win32com.client.Dispatch("Outlook.Application")
            self.namespace = self.outlook.GetNamespace("MAPI")
            print("âœ… Conectado a Outlook corporativo")
        except Exception as e:
            print(f"âŒ Error al conectar con Outlook: {e}")
            raise
    
    def obtener_carpeta_personalizada(self):
        """Obtiene la carpeta personalizada 'pruebatrx' desde Outlook"""
        try:
            # Obtener la bandeja de entrada principal
            inbox = self.namespace.GetDefaultFolder(6)  # 6 = Inbox
            
            # Intentar acceder a la carpeta personalizada
            carpeta_objetivo = inbox.Folders(self.carpeta_outlook_objetivo)
            print(f"âœ… Carpeta '{self.carpeta_outlook_objetivo}' encontrada")
            return carpeta_objetivo
            
        except Exception as e:
            print(f"âŒ Error: No se encontrÃ³ la carpeta '{self.carpeta_outlook_objetivo}' en Outlook")
            print("ğŸ“ Carpetas disponibles en Inbox:")
            
            try:
                # Listar carpetas disponibles para ayudar al usuario
                inbox = self.namespace.GetDefaultFolder(6)
                for subcarpeta in inbox.Folders:
                    print(f"  - {subcarpeta.Name}")
                    
                # TambiÃ©n listar carpetas principales
                print("\nğŸ“ Buzones principales:")
                for buzones in self.namespace.Folders:
                    print(f"  - {buzones.Name}")
                    
            except Exception as list_error:
                print(f"Error al listar carpetas: {list_error}")
            
            raise Exception(f"Carpeta '{self.carpeta_outlook_objetivo}' no encontrada")
    
    def procesar_correo_diario(self):
        """FunciÃ³n principal que ejecuta todo el flujo"""
        print(f"ğŸš€ Iniciando proceso diario - {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        
        # Paso 1: Extraer Excel del ZIP del correo
        datos_dia = self.extraer_excel_de_correo()
        
        if datos_dia is not None:
            print(f"ğŸ“Š Datos extraÃ­dos: {len(datos_dia)} registros")
            
            # Paso 2: Guardar Excel del dÃ­a
            archivo_diario = self.guardar_excel_diario(datos_dia)
            
            # Paso 3: Actualizar dashboard histÃ³rico
            self.actualizar_dashboard_historico(datos_dia)
            
            # Paso 4: Generar grÃ¡ficas del dÃ­a
            graficas_generadas = self.generar_graficas_diarias(datos_dia)
            
            # Paso 5: Enviar reporte por Outlook corporativo
            self.enviar_reporte_outlook(datos_dia, graficas_generadas)
            
            # Paso 6: Limpiar archivos temporales
            self.limpiar_archivos_temporales()
            
            print("âœ… Proceso completado exitosamente")
        else:
            print("âš ï¸  No se encontraron datos para procesar hoy")
    
    def extraer_excel_de_correo(self):
        """Extrae Excel del ZIP adjunto en correos de hoy desde la carpeta 'pruebatrx'"""
        try:
            # Obtener la carpeta personalizada
            carpeta_objetivo = self.obtener_carpeta_personalizada()
            
            # Filtrar correos de hoy
            hoy = datetime.now()
            fecha_filtro = hoy.strftime("%m/%d/%Y")
            
            print(f"ğŸ” Buscando correos del {fecha_filtro} en la carpeta '{self.carpeta_outlook_objetivo}'...")
            
            # Restrict para filtrar correos de hoy
            filtro = f"[ReceivedTime] >= '{fecha_filtro}' AND [ReceivedTime] < '{(hoy + timedelta(days=1)).strftime('%m/%d/%Y')}'"
            messages = carpeta_objetivo.Items.Restrict(filtro)
            
            print(f"ğŸ“§ Encontrados {messages.Count} correos de hoy en '{self.carpeta_outlook_objetivo}'")
            
            for message in messages:
                if self.es_correo_reporte_fraude(message):
                    print(f"âœ… Correo de reporte encontrado: {message.Subject}")
                    
                    # Buscar archivos ZIP en adjuntos
                    for attachment in message.Attachments:
                        if attachment.FileName.lower().endswith('.zip'):
                            print(f"ğŸ“ Procesando ZIP: {attachment.FileName}")
                            
                            # Guardar ZIP temporalmente
                            zip_path = os.path.abspath(os.path.join(self.carpeta_temp, attachment.FileName))
                            attachment.SaveAsFile(zip_path)
                            
                            # Extraer Excel del ZIP
                            datos = self.extraer_excel_de_zip(zip_path)
                            
                            if datos is not None:
                                print("âœ… Excel extraÃ­do exitosamente")
                                return datos
            
            print(f"âŒ No se encontrÃ³ correo con ZIP de reportes en la carpeta '{self.carpeta_outlook_objetivo}'")
            return None
            
        except Exception as e:
            print(f"âŒ Error al procesar correo: {e}")
            return None
    
    def es_correo_reporte_fraude(self, message):
        """Determina si el correo contiene el reporte diario de fraudes"""
        try:
            # Obtener informaciÃ³n del correo de forma segura
            remitente = str(message.SenderEmailAddress).lower() if message.SenderEmailAddress else ""
            asunto = str(message.Subject).lower() if message.Subject else ""
            
            # AJUSTA ESTOS CRITERIOS SEGÃšN TU BANCO:
            criterios_remitente = [
                "josemayker75@gmail.com"  # CAMBIAR POR TUS EMAILS REALES
                #"reportes@banco.com", 
                #"riesgo@banco.com",
                #"fraudes@banco.com"
            ]
            
            criterios_asunto = [
                "reporte diario",
                "fraudes diarios", 
                "transacciones sospechosas",
                "alerta fraude",
                "reporte de riesgo",
                "prueba trx",  # Agregado para coincidir con el nombre de tu carpeta
                "test"        # Por si usas correos de prueba
            ]
            
            # Verificar remitente
            remitente_valido = any(criterio in remitente for criterio in criterios_remitente)
            
            # Verificar asunto
            asunto_valido = any(criterio in asunto for criterio in criterios_asunto)
            
            # Verificar que tenga adjuntos
            tiene_adjuntos = message.Attachments.Count > 0
            
            if remitente_valido or asunto_valido:
                print(f"ğŸ“‹ Candidato encontrado - Remitente: {remitente}, Asunto: {asunto}")
            
            return (remitente_valido or asunto_valido) and tiene_adjuntos
            
        except Exception as e:
            print(f"Error al evaluar correo: {e}")
            return False
    
    def extraer_excel_de_zip(self, zip_path):
        """Extrae Excel del archivo ZIP"""
        try:
            print(f"ğŸ” Verificando ZIP: {zip_path}")
            print(f"ğŸ“ Archivo existe: {os.path.exists(zip_path)}")
            
            if not os.path.exists(zip_path):
                print(f"âŒ El archivo ZIP no existe: {zip_path}")
                return None
                
            print(f"ğŸ“¦ TamaÃ±o del ZIP: {os.path.getsize(zip_path)} bytes")
            
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                archivos = zip_ref.namelist()
                print(f"ğŸ“‚ Archivos en ZIP: {archivos}")
                
                # Buscar archivo Excel (prioritizar .xlsx sobre .xls)
                archivos_excel = [f for f in archivos if f.lower().endswith(('.xlsx', '.xls'))]
                
                if not archivos_excel:
                    print("âŒ No se encontrÃ³ archivo Excel en el ZIP")
                    print(f"ğŸ” Archivos disponibles: {archivos}")
                    return None
                
                # Tomar el primer Excel encontrado
                archivo_excel = archivos_excel[0]
                print(f"ğŸ“Š Procesando Excel: {archivo_excel}")
                
                # Verificar que la carpeta temporal exista para la extracciÃ³n
                if not os.path.exists(self.carpeta_temp):
                    os.makedirs(self.carpeta_temp, exist_ok=True)
                
                # Extraer a carpeta temporal
                zip_ref.extract(archivo_excel, self.carpeta_temp)
                
                # Cargar datos
                ruta_excel = os.path.join(self.carpeta_temp, archivo_excel)
                ruta_excel = os.path.abspath(ruta_excel)
                
                print(f"ğŸ“‹ Ruta Excel extraÃ­do: {ruta_excel}")
                print(f"ğŸ“ Excel existe: {os.path.exists(ruta_excel)}")
                
                # Intentar diferentes mÃ©todos de lectura
                try:
                    datos = pd.read_excel(ruta_excel)
                    print(f"âœ… MÃ©todo 1 exitoso: pd.read_excel()")
                except Exception as e:
                    print(f"âš ï¸  Error con mÃ©todo 1, intentando con engine='openpyxl': {e}")
                    try:
                        datos = pd.read_excel(ruta_excel, engine='openpyxl')
                        print(f"âœ… MÃ©todo 2 exitoso: engine='openpyxl'")
                    except Exception as e2:
                        print(f"âš ï¸  Error con mÃ©todo 2, intentando con engine='xlrd': {e2}")
                        datos = pd.read_excel(ruta_excel, engine='xlrd')
                        print(f"âœ… MÃ©todo 3 exitoso: engine='xlrd'")
                
                # Limpiar archivo temporal Excel
                try:
                    os.remove(ruta_excel)
                    print(f"ğŸ§¹ Archivo temporal Excel eliminado")
                except:
                    print(f"âš ï¸  No se pudo eliminar archivo temporal: {ruta_excel}")
                
                print(f"âœ… Excel cargado: {len(datos)} filas, {len(datos.columns)} columnas")
                print(f"ğŸ“Š Columnas: {list(datos.columns)}")
                
                return datos
                
        except zipfile.BadZipFile:
            print(f"âŒ El archivo no es un ZIP vÃ¡lido: {zip_path}")
            return None
        except Exception as e:
            print(f"âŒ Error al extraer ZIP: {e}")
            print(f"ğŸ” Tipo de error: {type(e)}")
            return None
        finally:
            # Limpiar ZIP temporal
            try:
                if os.path.exists(zip_path):
                    os.remove(zip_path)
                    print(f"ğŸ§¹ ZIP temporal eliminado: {zip_path}")
            except Exception as cleanup_error:
                print(f"âš ï¸  Error al limpiar ZIP: {cleanup_error}")
    
    def guardar_excel_diario(self, datos):
        """Guarda el Excel del dÃ­a en la carpeta diarios"""
        fecha_hoy = datetime.now().strftime("%Y%m%d")
        nombre_archivo = f"fraudes_{fecha_hoy}.xlsx"
        ruta_archivo = os.path.join(self.carpeta_diarios, nombre_archivo)
        
        # Agregar timestamp para tracking
        datos_con_timestamp = datos.copy()
        datos_con_timestamp['fecha_procesamiento'] = datetime.now()
        
        datos_con_timestamp.to_excel(ruta_archivo, index=False)
        print(f"ğŸ’¾ Excel diario guardado: {nombre_archivo}")
        
        return ruta_archivo
    
    def actualizar_dashboard_historico(self, datos_nuevos):
        """Actualiza el Excel dashboard con los datos histÃ³ricos"""
        ruta_dashboard = os.path.join(self.carpeta_historicos, self.archivo_dashboard)
        
        try:
            if os.path.exists(ruta_dashboard):
                print("ğŸ“Š Cargando dashboard histÃ³rico...")
                datos_historicos = pd.read_excel(ruta_dashboard)
                
                # Evitar duplicados por fecha si existe columna fecha
                if 'fecha' in datos_nuevos.columns:
                    hoy = datetime.now().date()
                    datos_historicos = datos_historicos[
                        pd.to_datetime(datos_historicos['fecha'], errors='coerce').dt.date != hoy
                    ]
                    print(f"ğŸ§¹ Eliminados datos duplicados del dÃ­a {hoy}")
                
                datos_combinados = pd.concat([datos_historicos, datos_nuevos], 
                                           ignore_index=True, sort=False)
            else:
                print("ğŸ†• Creando nuevo dashboard histÃ³rico...")
                datos_combinados = datos_nuevos
            
            # Guardar dashboard actualizado
            datos_combinados.to_excel(ruta_dashboard, index=False)
            print(f"âœ… Dashboard actualizado: {len(datos_combinados)} registros totales")
            
        except Exception as e:
            print(f"âŒ Error al actualizar dashboard: {e}")
    
    def generar_graficas_diarias(self, datos):
        """Genera grÃ¡ficas con los datos del dÃ­a"""
        graficas_generadas = []
        fecha_hoy = datetime.now().strftime("%Y%m%d")
        
        try:
            # Configurar estilo
            sns.set_style("whitegrid")
            plt.style.use('default')
            
            print("ğŸ“ˆ Generando grÃ¡ficas...")
            
            # Detectar automÃ¡ticamente columnas relevantes
            columnas = datos.columns.tolist()
            print(f"ğŸ“‹ Columnas disponibles: {columnas}")
            
            # Buscar columnas para anÃ¡lisis (flexible)
            col_negocio = None
            col_hora = None
            col_monto = None
            col_fecha = None
            
            for col in columnas:
                col_lower = col.lower()
                if 'negocio' in col_lower or 'comercio' in col_lower or 'tienda' in col_lower:
                    col_negocio = col
                elif 'hora' in col_lower or 'time' in col_lower:
                    col_hora = col
                elif 'monto' in col_lower or 'importe' in col_lower or 'valor' in col_lower:
                    col_monto = col
                elif 'fecha' in col_lower or 'date' in col_lower:
                    col_fecha = col
            
            # GrÃ¡fica 1: Total de fraudes (siempre se puede hacer)
            plt.figure(figsize=(10, 6))
            total_fraudes = len(datos)
            
            plt.bar(['Total de Fraudes Detectados'], [total_fraudes], 
                   color='#e74c3c', alpha=0.8)
            plt.title(f'Resumen Monitor SAC - {datetime.now().strftime("%d/%m/%Y")} (Carpeta: pruebatrx)', 
                     fontsize=14, fontweight='bold')
            plt.ylabel('Cantidad de Fraudes')
            
            # Agregar valor en la barra
            plt.text(0, total_fraudes/2, str(total_fraudes), 
                    ha='center', va='center', fontsize=16, fontweight='bold', color='white')
            
            archivo_resumen = os.path.join(self.carpeta_graficas, f"resumen_total_{fecha_hoy}.png")
            plt.tight_layout()
            plt.savefig(archivo_resumen, dpi=300, bbox_inches='tight')
            plt.close()
            graficas_generadas.append(archivo_resumen)
            
            # GrÃ¡fica 2: Fraudes por negocio (si existe la columna)
            if col_negocio:
                plt.figure(figsize=(12, 8))
                fraudes_por_negocio = datos[col_negocio].value_counts().head(10)
                
                sns.barplot(y=fraudes_por_negocio.index, x=fraudes_por_negocio.values, 
                           palette='viridis')
                plt.title(f'Top 10 Negocios con MÃ¡s Fraudes - {datetime.now().strftime("%d/%m/%Y")}',
                         fontsize=14, fontweight='bold')
                plt.xlabel('NÃºmero de Fraudes')
                plt.ylabel('Negocio/Comercio')
                
                archivo_negocio = os.path.join(self.carpeta_graficas, f"fraudes_negocio_{fecha_hoy}.png")
                plt.tight_layout()
                plt.savefig(archivo_negocio, dpi=300, bbox_inches='tight')
                plt.close()
                graficas_generadas.append(archivo_negocio)
            
            # GrÃ¡fica 3: Fraudes por hora (si existe la columna o se puede extraer)
            if col_hora or col_fecha:
                plt.figure(figsize=(12, 6))
                
                if col_hora:
                    # Si ya hay columna hora
                    if datos[col_hora].dtype == 'object':
                        # Si es texto, intentar extraer hora
                        try:
                            datos['hora_num'] = pd.to_datetime(datos[col_hora]).dt.hour
                        except:
                            datos['hora_num'] = datos[col_hora].astype(str).str.extract(r'(\d{1,2})').astype(int)
                    else:
                        datos['hora_num'] = datos[col_hora]
                elif col_fecha:
                    # Extraer hora de timestamp
                    datos['hora_num'] = pd.to_datetime(datos[col_fecha]).dt.hour
                
                if 'hora_num' in datos.columns:
                    fraudes_por_hora = datos['hora_num'].value_counts().sort_index()
                    
                    sns.lineplot(x=fraudes_por_hora.index, y=fraudes_por_hora.values, 
                                marker='o', markersize=8, linewidth=2)
                    plt.title(f'DistribuciÃ³n de Fraudes por Horario - {datetime.now().strftime("%d/%m/%Y")}',
                             fontsize=14, fontweight='bold')
                    plt.xlabel('Hora del DÃ­a')
                    plt.ylabel('NÃºmero de Fraudes')
                    plt.xticks(range(0, 24))
                    plt.grid(True, alpha=0.3)
                    
                    archivo_horario = os.path.join(self.carpeta_graficas, f"fraudes_horario_{fecha_hoy}.png")
                    plt.tight_layout()
                    plt.savefig(archivo_horario, dpi=300, bbox_inches='tight')
                    plt.close()
                    graficas_generadas.append(archivo_horario)
            
            # GrÃ¡fica 4: DistribuciÃ³n por monto (si existe)
            if col_monto:
                plt.figure(figsize=(10, 6))
                
                # Limpiar datos de monto
                montos = pd.to_numeric(datos[col_monto], errors='coerce').dropna()
                
                if len(montos) > 0:
                    sns.histplot(montos, bins=20, kde=True, alpha=0.7)
                    plt.title(f'DistribuciÃ³n de Montos de Fraude - {datetime.now().strftime("%d/%m/%Y")}',
                             fontsize=14, fontweight='bold')
                    plt.xlabel('Monto ($)')
                    plt.ylabel('Frecuencia')
                    
                    archivo_montos = os.path.join(self.carpeta_graficas, f"distribucion_montos_{fecha_hoy}.png")
                    plt.tight_layout()
                    plt.savefig(archivo_montos, dpi=300, bbox_inches='tight')
                    plt.close()
                    graficas_generadas.append(archivo_montos)
            
            print(f"âœ… GrÃ¡ficas generadas: {len(graficas_generadas)}")
            return graficas_generadas
            
        except Exception as e:
            print(f"âŒ Error al generar grÃ¡ficas: {e}")
            return []
    
    def enviar_reporte_outlook(self, datos, graficas):
        """EnvÃ­a reporte usando Outlook corporativo"""
        try:
            print("ğŸ“§ Preparando envÃ­o por Outlook corporativo...")
            
            # Crear nuevo correo
            mail = self.outlook.CreateItem(0)  # 0 = MailItem
            
            # Configurar destinatarios - AJUSTA SEGÃšN TU BANCO
            destinatarios = [
                "20210832@lamolina.edu.pe"      # CAMBIAR POR TUS EMAILS REALES
                #"analisis.fraudes@banco.com", 
               # "seguridad.ti@banco.com"
            ]
            
            mail.To = "; ".join(destinatarios)
            
            # Asunto
            fecha_reporte = datetime.now().strftime("%d/%m/%Y")
            mail.Subject = f"[AUTOMATICO] Reporte Diario de Fraudes - {fecha_reporte} (Carpeta: pruebatrx)"
            
            # Preparar estadÃ­sticas
            total_fraudes = len(datos)
            columnas = datos.columns.tolist()
            
            # Buscar columna de negocio para estadÃ­sticas
            col_negocio = None
            for col in columnas:
                if 'negocio' in col.lower() or 'comercio' in col.lower():
                    col_negocio = col
                    break
            
            negocios_afectados = datos[col_negocio].nunique() if col_negocio else "N/A"
            
            # Buscar horario con mÃ¡s fraudes
            horario_pico = "N/A"
            try:
                if 'hora' in str(columnas).lower():
                    col_hora = [c for c in columnas if 'hora' in c.lower()][0]
                    horario_pico = f"{datos[col_hora].mode()[0]}:00"
            except:
                pass
            
            # Cuerpo del correo
            mail.Body = f"""
REPORTE AUTOMATICO DE FRAUDES
Fuente: Carpeta Outlook 'pruebatrx'
Fecha: {fecha_reporte}
Hora de generaciÃ³n: {datetime.now().strftime("%H:%M:%S")}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“Š RESUMEN EJECUTIVO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸš¨ Total de fraudes detectados: {total_fraudes}
ğŸ¢ Negocios/Comercios afectados: {negocios_afectados}
â° Horario con mayor incidencia: {horario_pico}
ğŸ“ Carpeta procesada: pruebatrx

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ˆ ANÃLISIS ADJUNTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Se adjuntan las siguientes grÃ¡ficas de anÃ¡lisis:
â€¢ Resumen total de fraudes
â€¢ DistribuciÃ³n por negocios/comercios
â€¢ Patrones horarios de fraude
â€¢ AnÃ¡lisis de montos (si aplica)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”§ INFORMACIÃ“N TÃ‰CNICA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Columnas procesadas: {len(columnas)}
Campos analizados: {', '.join(columnas[:5])}{'...' if len(columnas) > 5 else ''}
Carpeta origen: pruebatrx

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Este reporte ha sido generado automÃ¡ticamente por el 
Sistema de Monitoreo de Fraudes del banco.

Para consultas tÃ©cnicas contactar al Ã¡rea de Sistemas.

CONFIDENCIAL - Solo para personal autorizado
            """
            
            # Adjuntar grÃ¡ficas
            for grafica in graficas:
                if os.path.exists(grafica):
                    mail.Attachments.Add(os.path.abspath(grafica))
                    print(f"ğŸ“ Adjuntado: {os.path.basename(grafica)}")
            
            # Adjuntar Excel del dÃ­a
            fecha_hoy = datetime.now().strftime("%Y%m%d")
            excel_diario = os.path.join(self.carpeta_diarios, f"fraudes_{fecha_hoy}.xlsx")
            if os.path.exists(excel_diario):
                mail.Attachments.Add(os.path.abspath(excel_diario))
                print(f"ğŸ“ Adjuntado: fraudes_{fecha_hoy}.xlsx")
            
            # Configurar importancia
            mail.Importance = 2  # 0=Low, 1=Normal, 2=High
            
            # Enviar correo
            mail.Send()
            
            print(f"âœ… Reporte enviado exitosamente a {len(destinatarios)} destinatarios")
            print(f"ğŸ“§ Destinatarios: {', '.join(destinatarios)}")
            
            # Guardar copia en Elementos enviados (automÃ¡tico)
            
        except Exception as e:
            print(f"âŒ Error al enviar correo: {e}")
            print("âš ï¸  Revisa que Outlook estÃ© abierto y funcionando")
    
    def limpiar_archivos_temporales(self):
        """Limpia archivos temporales"""
        try:
            # Limpiar carpeta temp
            for archivo in os.listdir(self.carpeta_temp):
                ruta_archivo = os.path.join(self.carpeta_temp, archivo)
                os.remove(ruta_archivo)
                
            # Opcional: Limpiar grÃ¡ficas antigas (mantener solo Ãºltimos 7 dÃ­as)
            fecha_limite = datetime.now() - timedelta(days=7)
            
            for archivo in os.listdir(self.carpeta_graficas):
                if archivo.endswith('.png'):
                    ruta_archivo = os.path.join(self.carpeta_graficas, archivo)
                    fecha_archivo = datetime.fromtimestamp(os.path.getctime(ruta_archivo))
                    
                    if fecha_archivo < fecha_limite:
                        os.remove(ruta_archivo)
                        print(f"ğŸ§¹ Eliminado archivo antiguo: {archivo}")
            
        except Exception as e:
            print(f"âš ï¸  Error al limpiar archivos temporales: {e}")
    
    def probar_conexion_carpeta(self):
        """FunciÃ³n de prueba para verificar conexiÃ³n a la carpeta personalizada"""
        try:
            print("ğŸ§ª Probando conexiÃ³n a la carpeta 'pruebatrx'...")
            carpeta_objetivo = self.obtener_carpeta_personalizada()
            
            print(f"âœ… ConexiÃ³n exitosa a la carpeta '{self.carpeta_outlook_objetivo}'")
            print(f"ğŸ“§ Total de correos en la carpeta: {carpeta_objetivo.Items.Count}")
            
            # Mostrar los Ãºltimos 5 correos
            items = carpeta_objetivo.Items
            items.Sort("[ReceivedTime]", True)  # True = Descending
            
            print("\nğŸ“‹ Ãšltimos 5 correos en la carpeta:")
            for i in range(min(5, items.Count)):
                correo = items[i]
                fecha = correo.ReceivedTime.strftime("%d/%m/%Y %H:%M")
                remitente = correo.SenderEmailAddress if correo.SenderEmailAddress else "N/A"
                asunto = correo.Subject[:50] + "..." if len(correo.Subject) > 50 else correo.Subject
                adjuntos = correo.Attachments.Count
                
                print(f"  {i+1}. [{fecha}] {remitente}")
                print(f"     Asunto: {asunto}")
                print(f"     Adjuntos: {adjuntos}")
                print()
                
            return True
            
        except Exception as e:
            print(f"âŒ Error al probar conexiÃ³n: {e}")
            return False

# FunciÃ³n principal
def main():
    """FunciÃ³n principal para ejecutar el procesamiento"""
    try:
        procesador = ProcesadorReportesFraudeOutlook()
        
        # Opcional: Probar conexiÃ³n primero
        if procesador.probar_conexion_carpeta():
            procesador.procesar_correo_diario()
        
    except Exception as e:
        print(f"ğŸ’¥ Error crÃ­tico en el proceso: {e}")
        print("ğŸ”§ Verifica que Outlook estÃ© abierto y funcionando")
        print("ğŸ”§ Verifica que la carpeta 'pruebatrx' exista en tu Outlook")

# Para programar ejecuciÃ³n automÃ¡tica
def programar_ejecucion_diaria():
    """Programa la ejecuciÃ³n diaria del reporte"""
    import schedule
    
    # Configurar para ejecutar a las 8:30 AM todos los dÃ­as
    schedule.every().day.at("08:30").do(main)
    
    print("â° Programador iniciado - EjecutarÃ¡ todos los dÃ­as a las 8:30 AM")
    print("ğŸ”„ Para detener presiona Ctrl+C")
    
    while True:
        schedule.run_pending()
        time.sleep(60)  # Verificar cada minuto

# FunciÃ³n de prueba independiente
def solo_probar_carpeta():
    """Solo prueba la conexiÃ³n a la carpeta sin procesar datos"""
    try:
        procesador = ProcesadorReportesFraudeOutlook()
        procesador.probar_conexion_carpeta()
    except Exception as e:
        print(f"ğŸ’¥ Error: {e}")

if __name__ == "__main__":
    # Ejecutar una vez
    main()
    
    # Descomentar para solo probar la carpeta:
    # solo_probar_carpeta()
    
    # Descomentar para programar ejecuciÃ³n diaria:
    # programar_ejecucion_diaria()
