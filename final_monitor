import win32com.client
import zipfile
import os
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from pathlib import Path
import time
import shutil # <--- IMPORTANTE: A√±adido para una limpieza robusta

class ProcesadorReportesFraudeOutlook:
    def __init__(self):
        self.carpeta_historicos = "datos_historicos"
        self.carpeta_diarios = "datos_diarios"
        self.carpeta_temp = "temp"
        self.carpeta_graficas = "graficas_reportes"
        self.archivo_dashboard = "dashboard_fraudes.xlsx"
        
        # --- CAMBIO: Adaptado a tu carpeta real ---
        self.carpeta_outlook_objetivo = "monitor_diario"
        
        # Crear carpetas si no existen
        for carpeta in [self.carpeta_historicos, self.carpeta_diarios, 
                        self.carpeta_temp, self.carpeta_graficas]:
            Path(carpeta).mkdir(exist_ok=True)
        
        # Conectar a Outlook corporativo
        try:
            self.outlook = win32com.client.Dispatch("Outlook.Application")
            self.namespace = self.outlook.GetNamespace("MAPI")
            print("‚úÖ Conectado a Outlook corporativo")
        except Exception as e:
            print(f"‚ùå Error al conectar con Outlook: {e}")
            raise
    
    def obtener_carpeta_personalizada(self):
        """Obtiene la carpeta personalizada desde Outlook"""
        try:
            inbox = self.namespace.GetDefaultFolder(6)  # 6 = Inbox
            carpeta_objetivo = inbox.Folders(self.carpeta_outlook_objetivo)
            print(f"‚úÖ Carpeta '{self.carpeta_outlook_objetivo}' encontrada")
            return carpeta_objetivo
        except Exception:
            print(f"‚ùå Error: No se encontr√≥ la carpeta '{self.carpeta_outlook_objetivo}' en tu Bandeja de Entrada.")
            # ... (c√≥digo para listar carpetas)
            raise Exception(f"Carpeta '{self.carpeta_outlook_objetivo}' no encontrada")
    
    def procesar_correo_diario(self):
        """Funci√≥n principal que ejecuta todo el flujo"""
        print(f"üöÄ Iniciando proceso diario - {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        datos_dia = self.extraer_excel_de_correo()
        
        if datos_dia is not None and not datos_dia.empty:
            print(f"üìä Datos extra√≠dos: {len(datos_dia)} registros")
            self.guardar_excel_diario(datos_dia)
            self.actualizar_dashboard_historico(datos_dia)
            graficas_generadas = self.generar_graficas_diarias(datos_dia)
            self.enviar_reporte_outlook(datos_dia, graficas_generadas)
            self.limpiar_archivos_temporales()
            print("‚úÖ Proceso completado exitosamente")
        else:
            print("‚ö†Ô∏è No se encontraron datos para procesar hoy")
    
    def extraer_excel_de_correo(self):
        """Extrae y combina todos los Excels del ZIP adjunto en correos de hoy."""
        try:
            carpeta_objetivo = self.obtener_carpeta_personalizada()
            hoy = datetime.now()
            fecha_filtro = hoy.strftime("%m/%d/%Y")
            print(f"üîç Buscando correos del {fecha_filtro} en la carpeta '{self.carpeta_outlook_objetivo}'...")
            
            filtro = f"[ReceivedTime] >= '{fecha_filtro}'"
            messages = carpeta_objetivo.Items.Restrict(filtro)
            messages.Sort("[ReceivedTime]", True) # Ordenar por m√°s reciente
            
            print(f"üìß Encontrados {messages.Count} correos de hoy en '{self.carpeta_outlook_objetivo}'")
            
            for message in messages:
                if self.es_correo_reporte_fraude(message):
                    print(f"‚úÖ Correo de reporte encontrado: {message.Subject}")
                    for attachment in message.Attachments:
                        if attachment.FileName.lower().endswith('.zip'):
                            print(f"üìÅ Procesando ZIP: {attachment.FileName}")
                            zip_path = os.path.abspath(os.path.join(self.carpeta_temp, attachment.FileName))
                            attachment.SaveAsFile(zip_path)
                            datos = self.extraer_y_combinar_excels_de_zip(zip_path)
                            if datos is not None:
                                print("‚úÖ Todos los Excels del ZIP han sido extra√≠dos y combinados.")
                                return datos
            
            print(f"‚ùå No se encontr√≥ un correo v√°lido con reportes en la carpeta '{self.carpeta_outlook_objetivo}' para hoy.")
            return None
        except Exception as e:
            print(f"‚ùå Error al procesar correo: {e}")
            return None
    
    def es_correo_reporte_fraude(self, message):
        """Determina si el correo contiene el reporte diario de fraudes"""
        try:
            remitente = ""
            if message.SenderEmailType == "EX":
                remitente = message.Sender.GetExchangeUser().PrimarySmtpAddress.lower()
            else:
                remitente = message.SenderEmailAddress.lower()

            asunto = str(message.Subject).lower()
            
            # --- CAMBIO: Criterios adaptados al correo real ---
            criterios_remitente = [
                "wilmer.valverde@scotiabank.com.pe"
            ]
            
            criterios_asunto = [
                "alertas por reporte", 
                "rep_8850" # Palabra clave del asunto
            ]
            
            remitente_valido = any(criterio in remitente for criterio in criterios_remitente)
            asunto_valido = any(criterio in asunto for criterio in criterios_asunto)
            tiene_adjuntos = message.Attachments.Count > 0
            
            if (remitente_valido and asunto_valido and tiene_adjuntos):
                print(f"üìã Candidato encontrado - Remitente: {remitente}, Asunto: {asunto}")
                return True
            return False
        except Exception as e:
            print(f"Error al evaluar correo: {e}")
            return False
    
    def extraer_y_combinar_excels_de_zip(self, zip_path):
        """
        MEJORADO: Extrae todos los archivos Excel de un ZIP y los combina en un √∫nico DataFrame.
        """
        lista_dataframes = []
        try:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                archivos_excel = [f for f in zip_ref.namelist() if f.lower().endswith(('.xlsx', '.xls')) and not f.startswith('__MACOSX')]
                
                if not archivos_excel:
                    print("‚ùå No se encontraron archivos Excel en el ZIP.")
                    return None
                
                print(f"üìä Se encontraron {len(archivos_excel)} archivos Excel en el ZIP: {archivos_excel}")

                for archivo_excel in archivos_excel:
                    print(f"üîÑ Procesando: {archivo_excel}")
                    zip_ref.extract(archivo_excel, self.carpeta_temp)
                    ruta_excel_extraido = os.path.join(self.carpeta_temp, archivo_excel)
                    
                    try:
                        df_temp = pd.read_excel(ruta_excel_extraido)
                        lista_dataframes.append(df_temp)
                        print(f"  - Le√≠do exitosamente: {len(df_temp)} filas.")
                    except Exception as e:
                        print(f"  - ‚ö†Ô∏è No se pudo leer el archivo {archivo_excel}. Error: {e}")
            
            if not lista_dataframes:
                print("‚ùå No se pudo leer ning√∫n archivo Excel del ZIP.")
                return None

            # Combinar todos los DataFrames en uno solo
            datos_combinados = pd.concat(lista_dataframes, ignore_index=True)
            return datos_combinados
            
        except Exception as e:
            print(f"‚ùå Error al extraer y combinar Excels del ZIP: {e}")
            return None
        finally:
            # Limpieza del ZIP temporal
            if os.path.exists(zip_path):
                os.remove(zip_path)

    # --- NING√öN CAMBIO NECESARIO EN LAS SIGUIENTES FUNCIONES ---
    # (guardar_excel_diario, actualizar_dashboard_historico, generar_graficas_diarias)
    # ... (Pega aqu√≠ tus funciones sin modificar) ...

    def limpiar_archivos_temporales(self):
        """MEJORADO: Limpia archivos y carpetas temporales de forma robusta."""
        print("üßπ Limpiando archivos temporales...")
        try:
            if os.path.exists(self.carpeta_temp):
                shutil.rmtree(self.carpeta_temp) # Usa shutil para borrar la carpeta y todo su contenido
                print(f"üóëÔ∏è Carpeta temporal '{self.carpeta_temp}' eliminada.")
            
            os.makedirs(self.carpeta_temp, exist_ok=True) # La vuelve a crear vac√≠a
        except Exception as e:
            print(f"‚ö†Ô∏è Error al limpiar archivos temporales: {e}")

    def enviar_reporte_outlook(self, datos, graficas):
        """Env√≠a reporte usando Outlook corporativo"""
        try:
            print("üìß Preparando env√≠o por Outlook corporativo...")
            mail = self.outlook.CreateItem(0)
            
            # --- CAMBIO: Puedes ajustar los destinatarios ---
            destinatarios = [
                "jose.cordova@scotiabank.com.pe" # Tu correo corporativo
            ]
            mail.To = "; ".join(destinatarios)
            
            fecha_reporte = datetime.now().strftime("%d/%m/%Y")
            # --- CAMBIO: Asunto y cuerpo ahora son din√°micos ---
            mail.Subject = f"[AUTOMATICO] Reporte Diario de Fraudes - {fecha_reporte} (Carpeta: {self.carpeta_outlook_objetivo})"
            
            mail.Body = f"""
REPORTE AUTOMATICO DE FRAUDES
Fuente: Carpeta Outlook '{self.carpeta_outlook_objetivo}'
Fecha: {fecha_reporte}
Hora de generaci√≥n: {datetime.now().strftime("%H:%M:%S")}
{'-'*50}
üìä RESUMEN EJECUTIVO
{'-'*50}
üö® Total de transacciones analizadas: {len(datos)}
{'-'*50}
Este reporte ha sido generado autom√°ticamente.
            """
            
            for grafica in graficas:
                if os.path.exists(grafica):
                    mail.Attachments.Add(os.path.abspath(grafica))
                    print(f"üìé Adjuntado: {os.path.basename(grafica)}")
            
            fecha_hoy = datetime.now().strftime("%Y%m%d")
            excel_diario = os.path.join(self.carpeta_diarios, f"fraudes_{fecha_hoy}.xlsx")
            if os.path.exists(excel_diario):
                mail.Attachments.Add(os.path.abspath(excel_diario))
                print(f"üìé Adjuntado: fraudes_{fecha_hoy}.xlsx")
            
            mail.Importance = 2
            mail.Send()
            print(f"‚úÖ Reporte enviado exitosamente a: {', '.join(destinatarios)}")

        except Exception as e:
            print(f"‚ùå Error al enviar correo: {e}")

# ... (El resto de tu script principal para llamar a la clase no necesita cambios)

--------------------------------------------------------------------
====================================================================
import win32com.client
import zipfile
import os
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from pathlib import Path
import time

class ProcesadorReportesFraudeOutlook:
    def __init__(self):
        self.carpeta_historicos = "datos_historicos"
        self.carpeta_diarios = "datos_diarios"
        self.carpeta_temp = "temp"
        self.carpeta_graficas = "graficas_reportes"
        self.archivo_dashboard = "dashboard_fraudes.xlsx"
        
        # NUEVA: Nombre de la carpeta personalizada en Outlook
        self.carpeta_outlook_objetivo = "prueba trx"  # Con espacio como aparece en tu Outlook
        
        # Crear carpetas si no existen
        for carpeta in [self.carpeta_historicos, self.carpeta_diarios, 
                       self.carpeta_temp, self.carpeta_graficas]:
            Path(carpeta).mkdir(exist_ok=True)
        
        # Conectar a Outlook corporativo
        try:
            self.outlook = win32com.client.Dispatch("Outlook.Application")
            self.namespace = self.outlook.GetNamespace("MAPI")
            print("‚úÖ Conectado a Outlook corporativo")
        except Exception as e:
            print(f"‚ùå Error al conectar con Outlook: {e}")
            raise
    
    def obtener_carpeta_personalizada(self):
        """Obtiene la carpeta personalizada 'pruebatrx' desde Outlook"""
        try:
            # Obtener la bandeja de entrada principal
            inbox = self.namespace.GetDefaultFolder(6)  # 6 = Inbox
            
            # Intentar acceder a la carpeta personalizada
            carpeta_objetivo = inbox.Folders(self.carpeta_outlook_objetivo)
            print(f"‚úÖ Carpeta '{self.carpeta_outlook_objetivo}' encontrada")
            return carpeta_objetivo
            
        except Exception as e:
            print(f"‚ùå Error: No se encontr√≥ la carpeta '{self.carpeta_outlook_objetivo}' en Outlook")
            print("üìÅ Carpetas disponibles en Inbox:")
            
            try:
                # Listar carpetas disponibles para ayudar al usuario
                inbox = self.namespace.GetDefaultFolder(6)
                for subcarpeta in inbox.Folders:
                    print(f"  - {subcarpeta.Name}")
                    
                # Tambi√©n listar carpetas principales
                print("\nüìÅ Buzones principales:")
                for buzones in self.namespace.Folders:
                    print(f"  - {buzones.Name}")
                    
            except Exception as list_error:
                print(f"Error al listar carpetas: {list_error}")
            
            raise Exception(f"Carpeta '{self.carpeta_outlook_objetivo}' no encontrada")
    
    def procesar_correo_diario(self):
        """Funci√≥n principal que ejecuta todo el flujo"""
        print(f"üöÄ Iniciando proceso diario - {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        
        # Paso 1: Extraer Excel del ZIP del correo
        datos_dia = self.extraer_excel_de_correo()
        
        if datos_dia is not None:
            print(f"üìä Datos extra√≠dos: {len(datos_dia)} registros")
            
            # Paso 2: Guardar Excel del d√≠a
            archivo_diario = self.guardar_excel_diario(datos_dia)
            
            # Paso 3: Actualizar dashboard hist√≥rico
            self.actualizar_dashboard_historico(datos_dia)
            
            # Paso 4: Generar gr√°ficas del d√≠a
            graficas_generadas = self.generar_graficas_diarias(datos_dia)
            
            # Paso 5: Enviar reporte por Outlook corporativo
            self.enviar_reporte_outlook(datos_dia, graficas_generadas)
            
            # Paso 6: Limpiar archivos temporales
            self.limpiar_archivos_temporales()
            
            print("‚úÖ Proceso completado exitosamente")
        else:
            print("‚ö†Ô∏è  No se encontraron datos para procesar hoy")
    
    def extraer_excel_de_correo(self):
        """Extrae Excel del ZIP adjunto en correos de hoy desde la carpeta 'pruebatrx'"""
        try:
            # Obtener la carpeta personalizada
            carpeta_objetivo = self.obtener_carpeta_personalizada()
            
            # Filtrar correos de hoy
            hoy = datetime.now()
            fecha_filtro = hoy.strftime("%m/%d/%Y")
            
            print(f"üîç Buscando correos del {fecha_filtro} en la carpeta '{self.carpeta_outlook_objetivo}'...")
            
            # Restrict para filtrar correos de hoy
            filtro = f"[ReceivedTime] >= '{fecha_filtro}' AND [ReceivedTime] < '{(hoy + timedelta(days=1)).strftime('%m/%d/%Y')}'"
            messages = carpeta_objetivo.Items.Restrict(filtro)
            
            print(f"üìß Encontrados {messages.Count} correos de hoy en '{self.carpeta_outlook_objetivo}'")
            
            for message in messages:
                if self.es_correo_reporte_fraude(message):
                    print(f"‚úÖ Correo de reporte encontrado: {message.Subject}")
                    
                    # Buscar archivos ZIP en adjuntos
                    for attachment in message.Attachments:
                        if attachment.FileName.lower().endswith('.zip'):
                            print(f"üìÅ Procesando ZIP: {attachment.FileName}")
                            
                            # Guardar ZIP temporalmente
                            zip_path = os.path.abspath(os.path.join(self.carpeta_temp, attachment.FileName))
                            attachment.SaveAsFile(zip_path)
                            
                            # Extraer Excel del ZIP
                            datos = self.extraer_excel_de_zip(zip_path)
                            
                            if datos is not None:
                                print("‚úÖ Excel extra√≠do exitosamente")
                                return datos
            
            print(f"‚ùå No se encontr√≥ correo con ZIP de reportes en la carpeta '{self.carpeta_outlook_objetivo}'")
            return None
            
        except Exception as e:
            print(f"‚ùå Error al procesar correo: {e}")
            return None
    
    def es_correo_reporte_fraude(self, message):
        """Determina si el correo contiene el reporte diario de fraudes"""
        try:
            # Obtener informaci√≥n del correo de forma segura
            remitente = str(message.SenderEmailAddress).lower() if message.SenderEmailAddress else ""
            asunto = str(message.Subject).lower() if message.Subject else ""
            
            # AJUSTA ESTOS CRITERIOS SEG√öN TU BANCO:
            criterios_remitente = [
                "josemayker75@gmail.com"  # CAMBIAR POR TUS EMAILS REALES
                #"reportes@banco.com", 
                #"riesgo@banco.com",
                #"fraudes@banco.com"
            ]
            
            criterios_asunto = [
                "reporte diario",
                "fraudes diarios", 
                "transacciones sospechosas",
                "alerta fraude",
                "reporte de riesgo",
                "prueba trx",  # Agregado para coincidir con el nombre de tu carpeta
                "test"        # Por si usas correos de prueba
            ]
            
            # Verificar remitente
            remitente_valido = any(criterio in remitente for criterio in criterios_remitente)
            
            # Verificar asunto
            asunto_valido = any(criterio in asunto for criterio in criterios_asunto)
            
            # Verificar que tenga adjuntos
            tiene_adjuntos = message.Attachments.Count > 0
            
            if remitente_valido or asunto_valido:
                print(f"üìã Candidato encontrado - Remitente: {remitente}, Asunto: {asunto}")
            
            return (remitente_valido or asunto_valido) and tiene_adjuntos
            
        except Exception as e:
            print(f"Error al evaluar correo: {e}")
            return False
    
    def extraer_excel_de_zip(self, zip_path):
        """Extrae Excel del archivo ZIP"""
        try:
            print(f"üîç Verificando ZIP: {zip_path}")
            print(f"üìÅ Archivo existe: {os.path.exists(zip_path)}")
            
            if not os.path.exists(zip_path):
                print(f"‚ùå El archivo ZIP no existe: {zip_path}")
                return None
                
            print(f"üì¶ Tama√±o del ZIP: {os.path.getsize(zip_path)} bytes")
            
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                archivos = zip_ref.namelist()
                print(f"üìÇ Archivos en ZIP: {archivos}")
                
                # Buscar archivo Excel (prioritizar .xlsx sobre .xls)
                archivos_excel = [f for f in archivos if f.lower().endswith(('.xlsx', '.xls'))]
                
                if not archivos_excel:
                    print("‚ùå No se encontr√≥ archivo Excel en el ZIP")
                    print(f"üîç Archivos disponibles: {archivos}")
                    return None
                
                # Tomar el primer Excel encontrado
                archivo_excel = archivos_excel[0]
                print(f"üìä Procesando Excel: {archivo_excel}")
                
                # Verificar que la carpeta temporal exista para la extracci√≥n
                if not os.path.exists(self.carpeta_temp):
                    os.makedirs(self.carpeta_temp, exist_ok=True)
                
                # Extraer a carpeta temporal
                zip_ref.extract(archivo_excel, self.carpeta_temp)
                
                # Cargar datos
                ruta_excel = os.path.join(self.carpeta_temp, archivo_excel)
                ruta_excel = os.path.abspath(ruta_excel)
                
                print(f"üìã Ruta Excel extra√≠do: {ruta_excel}")
                print(f"üìÅ Excel existe: {os.path.exists(ruta_excel)}")
                
                # Intentar diferentes m√©todos de lectura
                try:
                    datos = pd.read_excel(ruta_excel)
                    print(f"‚úÖ M√©todo 1 exitoso: pd.read_excel()")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error con m√©todo 1, intentando con engine='openpyxl': {e}")
                    try:
                        datos = pd.read_excel(ruta_excel, engine='openpyxl')
                        print(f"‚úÖ M√©todo 2 exitoso: engine='openpyxl'")
                    except Exception as e2:
                        print(f"‚ö†Ô∏è  Error con m√©todo 2, intentando con engine='xlrd': {e2}")
                        datos = pd.read_excel(ruta_excel, engine='xlrd')
                        print(f"‚úÖ M√©todo 3 exitoso: engine='xlrd'")
                
                # Limpiar archivo temporal Excel
                try:
                    os.remove(ruta_excel)
                    print(f"üßπ Archivo temporal Excel eliminado")
                except:
                    print(f"‚ö†Ô∏è  No se pudo eliminar archivo temporal: {ruta_excel}")
                
                print(f"‚úÖ Excel cargado: {len(datos)} filas, {len(datos.columns)} columnas")
                print(f"üìä Columnas: {list(datos.columns)}")
                
                return datos
                
        except zipfile.BadZipFile:
            print(f"‚ùå El archivo no es un ZIP v√°lido: {zip_path}")
            return None
        except Exception as e:
            print(f"‚ùå Error al extraer ZIP: {e}")
            print(f"üîç Tipo de error: {type(e)}")
            return None
        finally:
            # Limpiar ZIP temporal
            try:
                if os.path.exists(zip_path):
                    os.remove(zip_path)
                    print(f"üßπ ZIP temporal eliminado: {zip_path}")
            except Exception as cleanup_error:
                print(f"‚ö†Ô∏è  Error al limpiar ZIP: {cleanup_error}")
    
    def guardar_excel_diario(self, datos):
        """Guarda el Excel del d√≠a en la carpeta diarios"""
        fecha_hoy = datetime.now().strftime("%Y%m%d")
        nombre_archivo = f"fraudes_{fecha_hoy}.xlsx"
        ruta_archivo = os.path.join(self.carpeta_diarios, nombre_archivo)
        
        # Agregar timestamp para tracking
        datos_con_timestamp = datos.copy()
        datos_con_timestamp['fecha_procesamiento'] = datetime.now()
        
        datos_con_timestamp.to_excel(ruta_archivo, index=False)
        print(f"üíæ Excel diario guardado: {nombre_archivo}")
        
        return ruta_archivo
    
    def actualizar_dashboard_historico(self, datos_nuevos):
        """Actualiza el Excel dashboard con los datos hist√≥ricos"""
        ruta_dashboard = os.path.join(self.carpeta_historicos, self.archivo_dashboard)
        
        try:
            if os.path.exists(ruta_dashboard):
                print("üìä Cargando dashboard hist√≥rico...")
                datos_historicos = pd.read_excel(ruta_dashboard)
                
                # Evitar duplicados por fecha si existe columna fecha
                if 'fecha' in datos_nuevos.columns:
                    hoy = datetime.now().date()
                    datos_historicos = datos_historicos[
                        pd.to_datetime(datos_historicos['fecha'], errors='coerce').dt.date != hoy
                    ]
                    print(f"üßπ Eliminados datos duplicados del d√≠a {hoy}")
                
                datos_combinados = pd.concat([datos_historicos, datos_nuevos], 
                                           ignore_index=True, sort=False)
            else:
                print("üÜï Creando nuevo dashboard hist√≥rico...")
                datos_combinados = datos_nuevos
            
            # Guardar dashboard actualizado
            datos_combinados.to_excel(ruta_dashboard, index=False)
            print(f"‚úÖ Dashboard actualizado: {len(datos_combinados)} registros totales")
            
        except Exception as e:
            print(f"‚ùå Error al actualizar dashboard: {e}")
    
    def generar_graficas_diarias(self, datos):
        """Genera gr√°ficas con los datos del d√≠a"""
        graficas_generadas = []
        fecha_hoy = datetime.now().strftime("%Y%m%d")
        
        try:
            # Configurar estilo
            sns.set_style("whitegrid")
            plt.style.use('default')
            
            print("üìà Generando gr√°ficas...")
            
            # Detectar autom√°ticamente columnas relevantes
            columnas = datos.columns.tolist()
            print(f"üìã Columnas disponibles: {columnas}")
            
            # Buscar columnas para an√°lisis (flexible)
            col_negocio = None
            col_hora = None
            col_monto = None
            col_fecha = None
            
            for col in columnas:
                col_lower = col.lower()
                if 'negocio' in col_lower or 'comercio' in col_lower or 'tienda' in col_lower:
                    col_negocio = col
                elif 'hora' in col_lower or 'time' in col_lower:
                    col_hora = col
                elif 'monto' in col_lower or 'importe' in col_lower or 'valor' in col_lower:
                    col_monto = col
                elif 'fecha' in col_lower or 'date' in col_lower:
                    col_fecha = col
            
            # Gr√°fica 1: Total de fraudes (siempre se puede hacer)
            plt.figure(figsize=(10, 6))
            total_fraudes = len(datos)
            
            plt.bar(['Total de Fraudes Detectados'], [total_fraudes], 
                   color='#e74c3c', alpha=0.8)
            plt.title(f'Resumen Monitor SAC - {datetime.now().strftime("%d/%m/%Y")} (Carpeta: pruebatrx)', 
                     fontsize=14, fontweight='bold')
            plt.ylabel('Cantidad de Fraudes')
            
            # Agregar valor en la barra
            plt.text(0, total_fraudes/2, str(total_fraudes), 
                    ha='center', va='center', fontsize=16, fontweight='bold', color='white')
            
            archivo_resumen = os.path.join(self.carpeta_graficas, f"resumen_total_{fecha_hoy}.png")
            plt.tight_layout()
            plt.savefig(archivo_resumen, dpi=300, bbox_inches='tight')
            plt.close()
            graficas_generadas.append(archivo_resumen)
            
            # Gr√°fica 2: Fraudes por negocio (si existe la columna)
            if col_negocio:
                plt.figure(figsize=(12, 8))
                fraudes_por_negocio = datos[col_negocio].value_counts().head(10)
                
                sns.barplot(y=fraudes_por_negocio.index, x=fraudes_por_negocio.values, 
                           palette='viridis')
                plt.title(f'Top 10 Negocios con M√°s Fraudes - {datetime.now().strftime("%d/%m/%Y")}',
                         fontsize=14, fontweight='bold')
                plt.xlabel('N√∫mero de Fraudes')
                plt.ylabel('Negocio/Comercio')
                
                archivo_negocio = os.path.join(self.carpeta_graficas, f"fraudes_negocio_{fecha_hoy}.png")
                plt.tight_layout()
                plt.savefig(archivo_negocio, dpi=300, bbox_inches='tight')
                plt.close()
                graficas_generadas.append(archivo_negocio)
            
            # Gr√°fica 3: Fraudes por hora (si existe la columna o se puede extraer)
            if col_hora or col_fecha:
                plt.figure(figsize=(12, 6))
                
                if col_hora:
                    # Si ya hay columna hora
                    if datos[col_hora].dtype == 'object':
                        # Si es texto, intentar extraer hora
                        try:
                            datos['hora_num'] = pd.to_datetime(datos[col_hora]).dt.hour
                        except:
                            datos['hora_num'] = datos[col_hora].astype(str).str.extract(r'(\d{1,2})').astype(int)
                    else:
                        datos['hora_num'] = datos[col_hora]
                elif col_fecha:
                    # Extraer hora de timestamp
                    datos['hora_num'] = pd.to_datetime(datos[col_fecha]).dt.hour
                
                if 'hora_num' in datos.columns:
                    fraudes_por_hora = datos['hora_num'].value_counts().sort_index()
                    
                    sns.lineplot(x=fraudes_por_hora.index, y=fraudes_por_hora.values, 
                                marker='o', markersize=8, linewidth=2)
                    plt.title(f'Distribuci√≥n de Fraudes por Horario - {datetime.now().strftime("%d/%m/%Y")}',
                             fontsize=14, fontweight='bold')
                    plt.xlabel('Hora del D√≠a')
                    plt.ylabel('N√∫mero de Fraudes')
                    plt.xticks(range(0, 24))
                    plt.grid(True, alpha=0.3)
                    
                    archivo_horario = os.path.join(self.carpeta_graficas, f"fraudes_horario_{fecha_hoy}.png")
                    plt.tight_layout()
                    plt.savefig(archivo_horario, dpi=300, bbox_inches='tight')
                    plt.close()
                    graficas_generadas.append(archivo_horario)
            
            # Gr√°fica 4: Distribuci√≥n por monto (si existe)
            if col_monto:
                plt.figure(figsize=(10, 6))
                
                # Limpiar datos de monto
                montos = pd.to_numeric(datos[col_monto], errors='coerce').dropna()
                
                if len(montos) > 0:
                    sns.histplot(montos, bins=20, kde=True, alpha=0.7)
                    plt.title(f'Distribuci√≥n de Montos de Fraude - {datetime.now().strftime("%d/%m/%Y")}',
                             fontsize=14, fontweight='bold')
                    plt.xlabel('Monto ($)')
                    plt.ylabel('Frecuencia')
                    
                    archivo_montos = os.path.join(self.carpeta_graficas, f"distribucion_montos_{fecha_hoy}.png")
                    plt.tight_layout()
                    plt.savefig(archivo_montos, dpi=300, bbox_inches='tight')
                    plt.close()
                    graficas_generadas.append(archivo_montos)
            
            print(f"‚úÖ Gr√°ficas generadas: {len(graficas_generadas)}")
            return graficas_generadas
            
        except Exception as e:
            print(f"‚ùå Error al generar gr√°ficas: {e}")
            return []
    
    def enviar_reporte_outlook(self, datos, graficas):
        """Env√≠a reporte usando Outlook corporativo"""
        try:
            print("üìß Preparando env√≠o por Outlook corporativo...")
            
            # Crear nuevo correo
            mail = self.outlook.CreateItem(0)  # 0 = MailItem
            
            # Configurar destinatarios - AJUSTA SEG√öN TU BANCO
            destinatarios = [
                "20210832@lamolina.edu.pe"      # CAMBIAR POR TUS EMAILS REALES
                #"analisis.fraudes@banco.com", 
               # "seguridad.ti@banco.com"
            ]
            
            mail.To = "; ".join(destinatarios)
            
            # Asunto
            fecha_reporte = datetime.now().strftime("%d/%m/%Y")
            mail.Subject = f"[AUTOMATICO] Reporte Diario de Fraudes - {fecha_reporte} (Carpeta: pruebatrx)"
            
            # Preparar estad√≠sticas
            total_fraudes = len(datos)
            columnas = datos.columns.tolist()
            
            # Buscar columna de negocio para estad√≠sticas
            col_negocio = None
            for col in columnas:
                if 'negocio' in col.lower() or 'comercio' in col.lower():
                    col_negocio = col
                    break
            
            negocios_afectados = datos[col_negocio].nunique() if col_negocio else "N/A"
            
            # Buscar horario con m√°s fraudes
            horario_pico = "N/A"
            try:
                if 'hora' in str(columnas).lower():
                    col_hora = [c for c in columnas if 'hora' in c.lower()][0]
                    horario_pico = f"{datos[col_hora].mode()[0]}:00"
            except:
                pass
            
            # Cuerpo del correo
            mail.Body = f"""
REPORTE AUTOMATICO DE FRAUDES
Fuente: Carpeta Outlook 'pruebatrx'
Fecha: {fecha_reporte}
Hora de generaci√≥n: {datetime.now().strftime("%H:%M:%S")}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìä RESUMEN EJECUTIVO
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üö® Total de fraudes detectados: {total_fraudes}
üè¢ Negocios/Comercios afectados: {negocios_afectados}
‚è∞ Horario con mayor incidencia: {horario_pico}
üìÅ Carpeta procesada: pruebatrx

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìà AN√ÅLISIS ADJUNTO
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Se adjuntan las siguientes gr√°ficas de an√°lisis:
‚Ä¢ Resumen total de fraudes
‚Ä¢ Distribuci√≥n por negocios/comercios
‚Ä¢ Patrones horarios de fraude
‚Ä¢ An√°lisis de montos (si aplica)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üîß INFORMACI√ìN T√âCNICA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Columnas procesadas: {len(columnas)}
Campos analizados: {', '.join(columnas[:5])}{'...' if len(columnas) > 5 else ''}
Carpeta origen: pruebatrx

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Este reporte ha sido generado autom√°ticamente por el 
Sistema de Monitoreo de Fraudes del banco.

Para consultas t√©cnicas contactar al √°rea de Sistemas.

CONFIDENCIAL - Solo para personal autorizado
            """
            
            # Adjuntar gr√°ficas
            for grafica in graficas:
                if os.path.exists(grafica):
                    mail.Attachments.Add(os.path.abspath(grafica))
                    print(f"üìé Adjuntado: {os.path.basename(grafica)}")
            
            # Adjuntar Excel del d√≠a
            fecha_hoy = datetime.now().strftime("%Y%m%d")
            excel_diario = os.path.join(self.carpeta_diarios, f"fraudes_{fecha_hoy}.xlsx")
            if os.path.exists(excel_diario):
                mail.Attachments.Add(os.path.abspath(excel_diario))
                print(f"üìé Adjuntado: fraudes_{fecha_hoy}.xlsx")
            
            # Configurar importancia
            mail.Importance = 2  # 0=Low, 1=Normal, 2=High
            
            # Enviar correo
            mail.Send()
            
            print(f"‚úÖ Reporte enviado exitosamente a {len(destinatarios)} destinatarios")
            print(f"üìß Destinatarios: {', '.join(destinatarios)}")
            
            # Guardar copia en Elementos enviados (autom√°tico)
            
        except Exception as e:
            print(f"‚ùå Error al enviar correo: {e}")
            print("‚ö†Ô∏è  Revisa que Outlook est√© abierto y funcionando")
    
    def limpiar_archivos_temporales(self):
        """Limpia archivos temporales"""
        try:
            # Limpiar carpeta temp
            for archivo in os.listdir(self.carpeta_temp):
                ruta_archivo = os.path.join(self.carpeta_temp, archivo)
                os.remove(ruta_archivo)
                
            # Opcional: Limpiar gr√°ficas antigas (mantener solo √∫ltimos 7 d√≠as)
            fecha_limite = datetime.now() - timedelta(days=7)
            
            for archivo in os.listdir(self.carpeta_graficas):
                if archivo.endswith('.png'):
                    ruta_archivo = os.path.join(self.carpeta_graficas, archivo)
                    fecha_archivo = datetime.fromtimestamp(os.path.getctime(ruta_archivo))
                    
                    if fecha_archivo < fecha_limite:
                        os.remove(ruta_archivo)
                        print(f"üßπ Eliminado archivo antiguo: {archivo}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error al limpiar archivos temporales: {e}")
    
    def probar_conexion_carpeta(self):
        """Funci√≥n de prueba para verificar conexi√≥n a la carpeta personalizada"""
        try:
            print("üß™ Probando conexi√≥n a la carpeta 'pruebatrx'...")
            carpeta_objetivo = self.obtener_carpeta_personalizada()
            
            print(f"‚úÖ Conexi√≥n exitosa a la carpeta '{self.carpeta_outlook_objetivo}'")
            print(f"üìß Total de correos en la carpeta: {carpeta_objetivo.Items.Count}")
            
            # Mostrar los √∫ltimos 5 correos
            items = carpeta_objetivo.Items
            items.Sort("[ReceivedTime]", True)  # True = Descending
            
            print("\nüìã √öltimos 5 correos en la carpeta:")
            for i in range(min(5, items.Count)):
                correo = items[i]
                fecha = correo.ReceivedTime.strftime("%d/%m/%Y %H:%M")
                remitente = correo.SenderEmailAddress if correo.SenderEmailAddress else "N/A"
                asunto = correo.Subject[:50] + "..." if len(correo.Subject) > 50 else correo.Subject
                adjuntos = correo.Attachments.Count
                
                print(f"  {i+1}. [{fecha}] {remitente}")
                print(f"     Asunto: {asunto}")
                print(f"     Adjuntos: {adjuntos}")
                print()
                
            return True
            
        except Exception as e:
            print(f"‚ùå Error al probar conexi√≥n: {e}")
            return False

# Funci√≥n principal
def main():
    """Funci√≥n principal para ejecutar el procesamiento"""
    try:
        procesador = ProcesadorReportesFraudeOutlook()
        
        # Opcional: Probar conexi√≥n primero
        if procesador.probar_conexion_carpeta():
            procesador.procesar_correo_diario()
        
    except Exception as e:
        print(f"üí• Error cr√≠tico en el proceso: {e}")
        print("üîß Verifica que Outlook est√© abierto y funcionando")
        print("üîß Verifica que la carpeta 'pruebatrx' exista en tu Outlook")

# Para programar ejecuci√≥n autom√°tica
def programar_ejecucion_diaria():
    """Programa la ejecuci√≥n diaria del reporte"""
    import schedule
    
    # Configurar para ejecutar a las 8:30 AM todos los d√≠as
    schedule.every().day.at("08:30").do(main)
    
    print("‚è∞ Programador iniciado - Ejecutar√° todos los d√≠as a las 8:30 AM")
    print("üîÑ Para detener presiona Ctrl+C")
    
    while True:
        schedule.run_pending()
        time.sleep(60)  # Verificar cada minuto

# Funci√≥n de prueba independiente
def solo_probar_carpeta():
    """Solo prueba la conexi√≥n a la carpeta sin procesar datos"""
    try:
        procesador = ProcesadorReportesFraudeOutlook()
        procesador.probar_conexion_carpeta()
    except Exception as e:
        print(f"üí• Error: {e}")

if __name__ == "__main__":
    # Ejecutar una vez
    main()
    
    # Descomentar para solo probar la carpeta:
    # solo_probar_carpeta()
    
    # Descomentar para programar ejecuci√≥n diaria:
    # programar_ejecucion_diaria()
