import win32com.client
import pandas as pd
import re
import os

# --- FUNCIÓN DE LIMPIEZA (Se mantiene igual) ---
def limpiar_html_a_texto(html_sucio):
    """
    Convierte el HTML en texto plano para la búsqueda por Regex.
    """
    if not html_sucio: return ""
    texto = html_sucio.replace('<br>', ' ').replace('</td>', ' ').replace('</div>', ' ')
    texto_limpio = re.sub(r'<[^>]+>', ' ', texto)
    texto_final = texto_limpio.replace('&nbsp;', ' ').replace('\r', '').replace('\n', '')
    return re.sub(' +', ' ', texto_final).strip()

# --- FUNCIÓN PRINCIPAL (Lógica de guardado CORREGIDA) ---
def procesar_correos_ips_hashes():
    print("--- INICIANDO EXTRACCIÓN DE IPS Y HASHES ---")
    
    # 1. CONEXIÓN OUTLOOK Y CARPETA
    # ... (Se mantiene igual)
    try:
        outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
        inbox = outlook.GetDefaultFolder(6)
        carpeta_destino = inbox.Folders("ips_Hash") 
    except Exception as e:
        print("Error: No se encuentra la carpeta 'ips_Hash'. Verifica el nombre.")
        return

    # 2. OBTENER CORREOS NO LEÍDOS
    items = carpeta_destino.Items
    items.Sort("[ReceivedTime]", True)
    mensajes_filtrados = items.Restrict("[UnRead] = True")
    
    cantidad = mensajes_filtrados.Count
    print(f"Correos pendientes encontrados: {cantidad}")

    if cantidad == 0:
        return

    lista_mensajes = list(mensajes_filtrados)
    
    # Listas separadas para almacenar los resultados
    todos_los_hashes_nuevos = []
    todos_los_ips_nuevos = []

    # --- PATRONES REGEX (Se mantienen igual) ---
    regex_ip = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
    regex_hash = r'\b[a-fA-F0-9]{16,}\b'

    # 3. PROCESAR CADA CORREO
    for i, mensaje in enumerate(lista_mensajes):
        try:
            # ... (Lógica de extracción se mantiene igual)
            fecha_correo = str(mensaje.ReceivedTime)
            texto_cuerpo = limpiar_html_a_texto(mensaje.HTMLBody)
            
            hashes_encontrados = re.findall(regex_hash, texto_cuerpo)
            ips_encontradas = re.findall(regex_ip, texto_cuerpo)
            
            for h in hashes_encontrados:
                # Filtro simple para no guardar el mismo hash del ejemplo si se repite
                if "1e2932eb0f962f6e" in h and len(hashes_encontrados) > 1: continue
                todos_los_hashes_nuevos.append({"Fecha_Correo": fecha_correo, "Hash_Detectado": h})
                
            for ip in ips_encontradas:
                 if ip.startswith("127.0") or ip.startswith("10."): continue
                 todos_los_ips_nuevos.append({"Fecha_Correo": fecha_correo, "IP_Detectada": ip})

            # Marcar como leído
            mensaje.UnRead = False
            mensaje.Save()

        except Exception as e:
            print(f"Error en correo {i+1}: {e}")
            continue

    # 4. GUARDAR EN EXCEL CON DOS HOJAS (Lógica CORREGIDA)
    archivo_excel = "Base_IPs_Hashes.xlsx"
    df_hashes_nuevos = pd.DataFrame(todos_los_hashes_nuevos)
    df_ips_nuevos = pd.DataFrame(todos_los_ips_nuevos)
    
    print(f"Se encontraron {len(df_hashes_nuevos)} Hashes y {len(df_ips_nuevos)} IPs en total.")

    if not df_hashes_nuevos.empty or not df_ips_nuevos.empty:
        
        # Leemos los datos antiguos si existen
        df_hashes_final = pd.DataFrame()
        df_ips_final = pd.DataFrame()
        
        if os.path.exists(archivo_excel):
            try:
                # Intentar leer la pestaña de Hashes
                df_hashes_antiguos = pd.read_excel(archivo_excel, sheet_name='Hashes')
                df_hashes_final = pd.concat([df_hashes_antiguos, df_hashes_nuevos], ignore_index=True)
            except ValueError:
                # La hoja no existe, usamos solo los nuevos
                df_hashes_final = df_hashes_nuevos
            except Exception:
                 # Error de lectura (ej. archivo vacío o corrupto)
                 df_hashes_final = df_hashes_nuevos
                 
            try:
                # Intentar leer la pestaña de IPs
                df_ips_antiguos = pd.read_excel(archivo_excel, sheet_name='IPs')
                df_ips_final = pd.concat([df_ips_antiguos, df_ips_nuevos], ignore_index=True)
            except ValueError:
                # La hoja no existe, usamos solo los nuevos
                df_ips_final = df_ips_nuevos
            except Exception:
                 # Error de lectura (ej. archivo vacío o corrupto)
                 df_ips_final = df_ips_nuevos
        else:
            # Si el archivo no existe, los nuevos son los finales
            df_hashes_final = df_hashes_nuevos
            df_ips_final = df_ips_nuevos


        try:
            # Usamos pd.ExcelWriter en modo 'w' para SOBREESCRIBIR, pero con los datos viejos + nuevos
            with pd.ExcelWriter(archivo_excel, engine='openpyxl', mode='w') as writer:
                
                if not df_hashes_final.empty:
                    # Guardamos el resultado combinado en la pestaña 'Hashes'
                    df_hashes_final.to_excel(writer, sheet_name='Hashes', index=False)

                if not df_ips_final.empty:
                    # Guardamos el resultado combinado en la pestaña 'IPs'
                    df_ips_final.to_excel(writer, sheet_name='IPs', index=False)
                    
            print(f"¡LISTO! Datos guardados/actualizados en las pestañas 'Hashes' e 'IPs' de {archivo_excel}")

        except PermissionError:
            print("ERROR CRÍTICO: El Excel está abierto. Ciérralo y vuelve a ejecutar.")
        except Exception as e:
             print(f"Error guardando Excel: {e}")

    else:
        print("No se encontraron datos válidos de IP o Hash en los correos.")

if __name__ == "__main__":
    procesar_correos_ips_hashes()
